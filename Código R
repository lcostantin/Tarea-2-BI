#Tarea 1
#Lucas Costantini	/	Seccion: 02
#Maria Lopez		/	Seccion: 01
#Catalina Martinez	/	Seccion: 02
#Ignacio Neira		/	Seccion: 01






install.packages("readxl")
install.packages("lattice")
install.packages("mice")
install.packages("dplyr")
install.packages("corrr")
install.packages("corrplot")
install.packages("tidyr")
install.packages("lubridate")
install.packages("rlang")
library(readxl)
library(lattice)
library(mice)
library(dplyr)
library(corrr)
library(corrplot)
library(tidyr)
library(lubridate)
library(rlang)

Base_2018<-read_excel("Tarea_1_BBDD_2018.xlsx",col_names = TRUE)
Base_Historica<-read_excel("Tarea_1_BBDD_Historica.xlsx",col_names = TRUE)
Base_Ciudades<-read_excel("BASE_Ciudades.xlsx",col_names = TRUE) ##//Base de creacion propia. Usando de base un Excel
#del gobierno con el listado de TODAS las ciudades de Chile y sus regiones respectivas, usando la lista de ciudades de 
#Base_2018 con la funcio eliminar duplicados de Excel, se genera un listado de TODAS las ciudades correspondientes en
#la Base_2018 con su respectiva region (en numero).

#####################Explorar los datos########################

#Verificamos si existe algun NA en la base
anyNA(Base_2018) #No existe ningun NA, por lo que se asume con solo hay NULLs.

function(y){sum(y == "NULL")} #Creamos la funcion para contabilizar los NULLs.
pNULL <- function(y){sum(y == "NULL")} #Guardamos la funcion para poder usarla.
apply(Base_2018, 2, pNULL) #Aplicamos la funcion.

#Podemos apreciar que existe un gran numero de NULLs, siendo en CUOTAS_PAG y MONTO_APROBADO
#la mayor cantidad de NULLs (22.658 en cada uno).

#Cambiar los nombres de BANCA, pasando todos a mayusculas.
Base_2018$BANCO <- toupper(Base_2018$BANCO)
Base_Historica$BANCO <- toupper(Base_Historica$BANCO)

#Cambiar los nombres de USER_LIQUIDADOR a todos en mayusculas.
Base_2018$USER_LIQUIDADOR <- toupper(Base_2018$USER_LIQUIDADOR)
Base_Historica$USER_LIQUIDADOR <- toupper(Base_Historica$USER_LIQUIDADOR)

#Transformamos la variable CLASE a binario, creando la nueva variable Clase_bin
Base_2018$Clase_bin = ifelse(Base_2018$CLASE == 'POSIBLE FRAUDE', 1, 0)

#Transformamos todos los SIN_CUOTA_COBERTURA = 0 a 1, ya que el pago de los seguros debe ser al menos en una cuota.
Base_2018$SIN_CUOTAS_COBERTURA[Base_2018$SIN_CUOTAS_COBERTURA == 0 ] <- 1

#Eliminamos la variable CAS_DESCRIPCION, ya que no se empleara en el trabajo
Base_2018$CAS_DESCRIPCION <- NULL

#Pueden existir casos de error entre SIN_FEC_DENUNCIA y SIN_FECHA_OCURRENCIA. Cuando SIN_FEC_DENUNCIA<SIN_FECHA_OCURRENCIA, 
#este error se considerara de registro, es decir, un error operativo por parte de un trabajador al momento de ingresar la fecha.

Base_2018$SIN_FEC_DENUNCIA <- ifelse(Base_2018$SIN_FEC_DENUNCIA < Base_2018$SIN_FECHA_OCURRENCIA, Base_2018$SIN_FECHA_OCURRENCIA, Base_2018$SIN_FEC_DENUNCIA)

#Se eliminaran las tuplas de personas que hayan pedido el pago de seguro por "despido cuando son menores de edad
# Primero creamos Edad_Sinistro, que es la diferencia entre el año en que ocurrió el siniestro y la edad de nacimiento

Base_2018$Edad_Siniestro <- year(ymd(Base_2018$SIN_FECHA_OCURRENCIA))-year(Base_2018$FECHA_NACIMIENTO)
Base_Historica$Edad_Siniestro <- year(ymd(Base_Historica$SIN_FECHA_OCURRENCIA))-year(Base_Historica$FECHA_NACIMIENTO)

Base_2018 <- Base_2018[!(Base_2018$Edad_Siniestro < 18 & Base_2018$CAU_DESCRIPCION == 'Despido'),]
Base_Historica <- Base_Historica[!(Base_Historica$Edad_Siniestro < 18 & Base_Historica$CAU_DESCRIPCION == 'Despido'),]

#En casos de defuncion, el denunciante y el asegurado no puede ser la misma persona

# DEN_ASEG_BIN toma valor 1 si el DNI_ASEGURADO_LLAVE es igual a DNI_DENUNCIANTE_LLAVE
# Si DEN_ASEG_BIN = 1 significa que el el aseguro es el mismo que denuncia, 0 en caso contrario

Base_2018 <- Base_2018 %>%
  mutate(DEN_ASEG_BIN = NA)
Base_2018$DEN_ASEG_BIN = ifelse(Base_2018$DNI_ASEGURADO_LLAVE == Base_2018$DNI_DENUNCIANTE_LLAVE, 1, 0)

Base_Historica <- Base_Historica %>%
  mutate(DEN_ASEG_BIN = NA)
Base_Historica$DEN_ASEG_BIN = ifelse(Base_Historica$DNI_ASEGURADO_LLAVE == Base_Historica$DNI_DENUNCIANTE_LLAVE, 1, 0)

Base_2018 <- Base_2018[!(Base_2018$DEN_ASEG_BIN == 1 & Base_2018$CAU_DESCRIPCION == 'Defunción'),]
Base_Historica <- Base_Historica[!(Base_Historica$DEN_ASEG_BIN == 1 & Base_Historica$CAU_DESCRIPCION == 'Defunción'),]

#####################Creacion dataframes a trabajar########################

#En honor a los recursos, separaremos la base en los casos de POSIBLE FRAUDE y NO, para poder correr el mice por separado

#Generamos la Base_Fraude // TRATAMIENTO BASE FRAUDE
Base_Fraude <- Base_2018 %>%
  filter(CLASE == "POSIBLE FRAUDE")

#Convertimos todos los NULLs a NAs
Base_Fraude$SIN_NOMBRE_CIUDAD[Base_Fraude$SIN_NOMBRE_CIUDAD == "NULL"] <- NA
Base_Fraude$CUOTAS_PAG[Base_Fraude$CUOTAS_PAG == "NULL"] <- NA
Base_Fraude$MONTO_APROBADO[Base_Fraude$MONTO_APROBADO == "NULL"] <- NA
Base_Fraude$CAU_DESCRIPCION[Base_Fraude$CAU_DESCRIPCION == "NULL"] <- NA

#Pasamos las variables que se vayan a ocupar en el mice a factor o numeric
Base_Fraude$CUOTAS_PAG<-as.numeric(Base_Fraude$CUOTAS_PAG)
Base_Fraude$MONTO_APROBADO<-as.numeric(Base_Fraude$MONTO_APROBADO)
Base_Fraude$SIN_NOMBRE_CIUDAD<-as.factor(Base_Fraude$SIN_NOMBRE_CIUDAD)
Base_Fraude$CAU_DESCRIPCION<-as.factor(Base_Fraude$CAU_DESCRIPCION)
Base_Fraude$SIN_FEC_DENUNCIA<-as.numeric(Base_Fraude$SIN_FEC_DENUNCIA)
Base_Fraude$SIN_FECHA_OCURRENCIA<-as.numeric(Base_Fraude$SIN_FECHA_OCURRENCIA)

#Crear DataFrame auxiliar y correr mice
Fraude_Mice <- Base_Fraude %>%
  select(SIN_CUOTAS_COBERTURA,SIN_FEC_DENUNCIA,SIN_FECHA_OCURRENCIA,Clase_bin,SIN_NOMBRE_CIUDAD,CUOTAS_PAG,MONTO_APROBADO,CAU_DESCRIPCION)
summary(Fraude_Mice)

mod_miceF <-mice(data = Fraude_Mice, m = 10,meth='cart')
Fraude_Mice_V1 <- mice::complete(mod_miceF)

anyNA(Fraude_Mice_V1)
sum(is.na(Fraude_Mice_V1))
summary(Fraude_Mice_V1)

#Los datos ya corregidos por Mice se integran a la base original, sobreescribiendo los anteriores
Base_Fraude$SIN_NOMBRE_CIUDAD <- Fraude_Mice_V1$SIN_NOMBRE_CIUDAD
Base_Fraude$CUOTAS_PAG <- Fraude_Mice_V1$CUOTAS_PAG
Base_Fraude$MONTO_APROBADO <- Fraude_Mice_V1$MONTO_APROBADO
Base_Fraude$CAU_DESCRIPCION <- Fraude_Mice_V1$CAU_DESCRIPCION

#Generamos la Base_No_Fraude // TRATAMIENTO VARIABLES NO FRAUDE
Base_No_Fraude <- Base_2018 %>%
  filter(CLASE == "NO")

# Convertimos todos los NULLs a NAs menos CAU_DESCRIPCION
Base_No_Fraude$SIN_NOMBRE_CIUDAD[Base_No_Fraude$SIN_NOMBRE_CIUDAD == "NULL"] <- NA
Base_No_Fraude$CUOTAS_PAG[Base_No_Fraude$CUOTAS_PAG == "NULL"] <- NA
Base_No_Fraude$MONTO_APROBADO[Base_No_Fraude$MONTO_APROBADO == "NULL"] <- NA
Base_No_Fraude$CAU_DESCRIPCION[Base_No_Fraude$CAU_DESCRIPCION == "NULL"] <- NA

#Pasar las variables que se vayan a ocupar en el mice a factor o num
Base_No_Fraude$CUOTAS_PAG<-as.numeric(Base_No_Fraude$CUOTAS_PAG)
Base_No_Fraude$MONTO_APROBADO<-as.numeric(Base_No_Fraude$MONTO_APROBADO)
Base_No_Fraude$SIN_NOMBRE_CIUDAD<-as.factor(Base_No_Fraude$SIN_NOMBRE_CIUDAD)
Base_No_Fraude$CAU_DESCRIPCION<-as.factor(Base_No_Fraude$CAU_DESCRIPCION)
Base_No_Fraude$SIN_FEC_DENUNCIA<-as.numeric(Base_No_Fraude$SIN_FEC_DENUNCIA)
Base_No_Fraude$SIN_FECHA_OCURRENCIA<-as.numeric(Base_No_Fraude$SIN_FECHA_OCURRENCIA)

#Crear DataFrame auxiliar y correr mice:
No_Fraude_Mice <- Base_No_Fraude %>%
  select(SIN_CUOTAS_COBERTURA,SIN_FEC_DENUNCIA,SIN_FECHA_OCURRENCIA,Clase_bin,SIN_NOMBRE_CIUDAD,CUOTAS_PAG,MONTO_APROBADO,CAU_DESCRIPCION)
summary(No_Fraude_Mice)

mod_miceNF <-mice(data = No_Fraude_Mice, m = 8,meth='cart')
No_Fraude_Mice_V1 <- mice::complete(mod_miceNF)

anyNA(No_Fraude_Mice_V1)
sum(is.na(No_Fraude_Mice_V1))
summary(No_Fraude_Mice_V1)

#Los datos ya corregidos por Mice se integran a la base original, sobreescribiendo los anteriores
Base_No_Fraude$SIN_NOMBRE_CIUDAD <- No_Fraude_Mice_V1$SIN_NOMBRE_CIUDAD
Base_No_Fraude$CUOTAS_PAG <- No_Fraude_Mice_V1$CUOTAS_PAG
Base_No_Fraude$MONTO_APROBADO <- No_Fraude_Mice_V1$MONTO_APROBADO
Base_No_Fraude$CAU_DESCRIPCION <- No_Fraude_Mice_V1$CAU_DESCRIPCION

#
#
#                                    	JUNTAR AMBAS TABLAR Y RANDOMIZAR
#
#

set.seed(42)
Base_2018 <- rbind(Base_Fraude,Base_No_Fraude)
shuffle <- sample(nrow(Base_2018))
Base_2018 <- Base_2018[shuffle,]


#Verificamos que no queden NAs
anyNA(Base_2018)
sum(is.na(Base_2018))
summary(Base_2018)

#
#  	Separacion tablas
#

##Base_AUX <- Base_2018 ///////// Respaldo de la Base_2018 post mice. En caso de que haya problemas mas adelante
##Base_2018 <- Base_AUX ###///USAR EN CASO DE ERROR MAS ADELANTE



#Separar LOT_FECHA_RECEPCION y HEV_TIME_MARK
Base_2018 <- separate(Base_2018, col = LOT_FECHA_RECEPCION, into = c("Fecha_Recepcion","Hora_Recepcion"), sep = " ")
Base_2018 <- separate(Base_2018, col = HEV_TIME_MARK , into = c("Fecha_HEV","Hora_HEV"), sep = " ")

#Volvemos a convertir SIN_FECHA_OCURRENCIA en Date
Base_2018$SIN_FECHA_OCURRENCIA <- as.Date(Base_2018$SIN_FECHA_OCURRENCIA / 60 / 60 / 24, origin = "1970-01-01")
#Volvemos a convertir SEN_FEC_DENUNCIA en Date
Base_2018$SIN_FEC_DENUNCIA <- as.Date(Base_2018$SIN_FEC_DENUNCIA / 60 / 60 / 24, origin = "1970-01-01")


#Separar fechas (class = Date) y omitir las horas
#*En caso de que todos estan de acuerdo en solo dejar la fecha
Base_2018$Fecha_Recepcion <- ymd(Base_2018$Fecha_Recepcion)
Base_2018$SIN_FECHA_OCURRENCIA <- ymd(Base_2018$SIN_FECHA_OCURRENCIA)
Base_2018$SIN_FEC_DENUNCIA <- ymd(Base_2018$SIN_FEC_DENUNCIA)
Base_2018$FECHA_NACIMIENTO <- ymd(Base_2018$FECHA_NACIMIENTO)
Base_2018$SIN_FEC_INIC_VIG_SINIESTRADO <- ymd(Base_2018$SIN_FEC_INIC_VIG_SINIESTRADO)
Base_2018$Fecha_HEV <- ymd(Base_2018$Fecha_HEV)
#Base_2018$HEV_TIME_MARK <- ymd(as.Date(Base_2018$HEV_TIME_MARK))

##¿Mantenemos la separacion con horas o solo ano, mes y dia?


#Correccion tildes SIN_ESTADO_ACTUAL
Base_2018$SIN_ESTADO_ACTUAL[Base_2018$SIN_ESTADO_ACTUAL=="En EvaluaciÂ¿n"]<-"En Evaluacion"

#
#  	Creacion de binarias
#

#Transformar CLASE a binaria
vector_fraude <- c(Base_2018$CLASE)
Base_2018$Clase_bin = ifelse(Base_2018$CLASE == 'POSIBLE FRAUDE', 1, 0)
#Clase_bin <- Base_2018$Clase_bin

#Transformar HEV_DETAILS a binaria y renombrar a DICTAMEN
vector_dictamen <- c(Base_2018$HEV_DETAILS)
Base_2018$DICTAMEN = ifelse(Base_2018$HEV_DETAILS == 'EstadoEvaluaciones:Dictamen Aprobado', 1, 0)
#Clase_DICTAMEN <- Base_2018$DICTAMEN

#Transformar SIN_PAGO_ESPECIAL a binaria
vector_SPE_BIN <- c(Base_2018$SIN_PAGO_ESPECIAL)
Base_2018$SPE_BIN = ifelse(Base_2018$SIN_PAGO_ESPECIAL == 'N', 0, 1)
#Clase_bin <- Base_2018$Clase_bin

#Transformar LOT_EXTERNO a binaria
vector_LE_BIN <- c(Base_2018$LOT_EXTERNO)
Base_2018$LE_BIN = ifelse(Base_2018$LOT_EXTERNO == 'N', 0, 1)
#Clase_bin <- Base_2018$Clase_bin


#Se separÃ³ la variable CAU_DESCRIPCION en 6 partes, CAUSA_Despido, CAUSA_Robo, CAUSA_Enfermedad, CAUSA_Clonacion, CAUSA_Incendio y CAUSA_Otros.
#CAUSA_Despido, CAUSA_Robo, CAUSA_Enfermedad, CAUSA_Clonacion se generaron ya que a partir de la muestra existente en Base_2018 se determina que estas son las 4 causas con mayor incidencias en 'POSIBLE FRAUDE'.
#Separando solo los casos de 'POSIBLE FRAUDE' (7.885 casos), se encontrÃ³ que la participaciÃ³n de las causas anteriormente mencionadas respecto al universo de 7.885 casos es la siguiente:
#Despido: 76,94%
#Robo: 2,4%
#Enfermedad + Enfermedades Graves: 15,39%
#Clonacion: 1,47%
#Ademas se toma la variable Incendio como causa separada, ya que si bien no represente un porcentaje importante de los casos de 'POSIBLE FRAUDE' de la base sobre la que se trabaja, en el Manual Antifraude de la compaÃ±Ã­a Caledonia Seguros se menciona como una causa importante de fraudes.
#El resto de las causas de fraudes fueron agrupadas en CAUSA_Otros.


#Creamos la variable CAUSA_Despido
Base_2018 <- Base_2018 %>%
  mutate(CAUSA_Despido = ifelse(Base_2018$CAU_DESCRIPCION == 'Despido', 1, 0))
#Creamos la variable CAUSA_Robo
Base_2018 <- Base_2018 %>%
  mutate(CAUSA_Robo = ifelse(Base_2018$CAU_DESCRIPCION == 'Robo', 1, 0))
#Creamos la variable CAUSA_Enfermedad
Base_2018 <- Base_2018 %>%
  mutate(CAUSA_Enfermedad = ifelse(Base_2018$CAU_DESCRIPCION == 'Enfermedad', 1, ifelse(Base_2018$CAU_DESCRIPCION =='Enfermedades Graves', 1, 0)))
#Creamos la variable CAUSA_Incendio
Base_2018 <- Base_2018 %>%
  mutate(CAUSA_Incendio = ifelse(Base_2018$CAU_DESCRIPCION == 'Incendio', 1, 0))
#Creamos la variable CAUSA_Otros
Base_2018$CAUSA_Otros = ifelse(Base_2018$CAU_DESCRIPCION == 'Despido', 0, ifelse(Base_2018$CAU_DESCRIPCION == 'Robo', 0, ifelse(Base_2018$CAU_DESCRIPCION == 'Enfermedad', 0, ifelse(Base_2018$CAU_DESCRIPCION == 'ClonaciÃ³n', 0, ifelse(Base_2018$CAU_DESCRIPCION == 'Incendio', 0,1)))))


# DEN_ASEG_BIN toma valor 1 si el DNI_ASEGURADO_LLAVE es igual a DNI_DENUNCIANTE_LLAVE
# Si DEN_ASEG_BIN = 1 significa que el el aseguro es el mismo que denuncia, 0 en caso contrario
Base_2018 <- Base_2018 %>%
  mutate(DEN_ASEG_BIN = NA)

Base_2018$DEN_ASEG_BIN = ifelse(Base_2018$DNI_ASEGURADO_LLAVE == Base_2018$DNI_DENUNCIANTE_LLAVE, 1, 0)

#
#  	CreaciÃ³n otras variables sobre la misma Base_2018
#

#Sacar la edad de la gente entre la fecha de nacimiento y la fecha de ocurrencia
#Base_2018$FECHA_NACIMIENTO<-as.character(Base_2018$FECHA_NACIMIENTO)
#Base_2018$FECHA_NACIMIENTO<-as.Date(Base_2018$FECHA_NACIMIENTO,"%Y-%m-%d")
#Base_2018$SIN_FECHA_OCURRENCIA<-as.character(Base_2018$SIN_FECHA_OCURRENCIA)
#Base_2018$SIN_FECHA_OCURRENCIA<-as.Date(Base_2018$SIN_FECHA_OCURRENCIA,"%Y-%m-%d")

#Calculamos la edad de las personas al momento de ocurrido el siniestro.
Base_2018$Edad_Siniestro <- year(ymd(Base_2018$SIN_FECHA_OCURRENCIA))-year(Base_2018$FECHA_NACIMIENTO)

#Creamos una funcion para corregir el posible error operativo, donde la fecha de ocurrencia del siniestro es anterior a la fecha de
#contratacion del seguro. En este caso, se asumirÃ¡ que si la fecha de ocurrencia es anterior a la contratacion, la fecha
#de ocurrencia sera igual a la de contratacion.

Base_2018$SIN_FECHA_OCURRENCIA <- ifelse(Base_2018$SIN_FECHA_OCURRENCIA < Base_2018$SIN_FEC_INIC_VIG_SINIESTRADO, Base_2018$SIN_FEC_INIC_VIG_SINIESTRADO, Base_2018$SIN_FECHA_OCURRENCIA)


###Generamos una Base_AUX_2 como respaldo hasta este punto en caso de tener problemas mas adelante.
###Base_AUX_2 <- Base_2018 ### /// APLICAR EN CASO DE ERRORES MaS ADELANTE

############################################
####      Valores BB.DD. Historica	    ####
############################################

###############MONTO_POR_DNI###############

Base_H <- data_frame(Base_Historica$DNI_ASEGURADO_LLAVE, Base_Historica$MONTO_APROBADO)
names(Base_H) = c("DNI_ASEGURADO_LLAVE", "MONTO_APROBADO")

apply(Base_H, 2, pMiss)
apply(Base_H, 2, pNULL)

#Borramos las filas con NA existentes (7 filas)
Base_H <- Base_H[!is.na(Base_H$DNI_ASEGURADO_LLAVE),]
#Transformamos los 'NULL' de MONTO_APROBADO a NA
Base_H$MONTO_APROBADO <- ifelse(Base_H$MONTO_APROBADO == "NULL", NA, Base_H$MONTO_APROBADO)
#Borramos las filas con NA de MONTO_APROBADO
Base_H <- Base_H[!is.na(Base_H$MONTO_APROBADO),]
#Ahora Base_H no tiene NULLs ni NAs
Base_H$MONTO_APROBADO <- as.numeric(Base_H$MONTO_APROBADO)

MONTO_POR_DNI <- Base_H %>% #Llamamos la base
  group_by(DNI_ASEGURADO_LLAVE) %>% #Agrupamos por DNI
  summarise(sumaDeMontos = sum(MONTO_APROBADO)) #Sumamos los montos asociados a cada DNI

###############N_POLIZAS_DNI###############
Base_H <- data_frame(Base_Historica$DNI_ASEGURADO_LLAVE, Base_Historica$POLIZA_SEGURO)
names(Base_H) = c("DNI_ASEGURADO_LLAVE", "POLIZA_SEGURO")

#Borramos las filas con NA existentes (7 filas)
Base_H <- Base_H[!is.na(Base_H$DNI_ASEGURADO_LLAVE),]
#Ahora Base_H no tiene NULLs ni NAs

N_POLIZAS_DNI <- Base_H %>% #Llamamos la base
  group_by(DNI_ASEGURADO_LLAVE) %>% #Agrupamos por DNI
  tally() #tally() cuenta cuantos elementos hay en cada grupo

names(N_POLIZAS_DNI) = c("DNI_ASEGURADO_LLAVE", "conteoPolizas") #Renombramos las columnas

#############N_SINIESTROS_DNI#############
Base_H <- data_frame(Base_Historica$DNI_ASEGURADO_LLAVE, Base_Historica$SIN_FECHA_OCURRENCIA)
names(Base_H) = c("DNI_ASEGURADO_LLAVE", "SIN_FECHA_OCURRENCIA")

#Borramos las filas con NA existentes (7 filas)
Base_H <- Base_H[!is.na(Base_H$DNI_ASEGURADO_LLAVE),]
#Ahora Base_H no tiene NULLs ni NAs

N_SINIESTROS_DNI <- Base_H %>% #Llamamos la base
  group_by(DNI_ASEGURADO_LLAVE) %>% #Agrupamos por DNI
  tally() #tally() cuenta cuantos elementos hay en cada grupo

names(N_SINIESTROS_DNI) = c("DNI_ASEGURADO_LLAVE", "conteoSiniestros") #Renombramos las columnas

#Creamos un vector con los DNI de BASE_2018 // Con este vector tenemos la lista de DNIs completa
Lista_DNI <- c(Base_2018$DNI_ASEGURADO_LLAVE)

#Reducimos el numero de obs. en N_SINIESTROS_DNI, eliminando todos los DNI que no estan en Base_2018
Numero_Siniestros <- N_SINIESTROS_DNI %>%
  filter(N_SINIESTROS_DNI$DNI_ASEGURADO_LLAVE %in% Lista_DNI)
#Reducimos el nÃºmero de obs. en MONTO_POR_DNII, eliminando todos los DNI que no estÃ¡n en Base_2018
Montos_Totales <- MONTO_POR_DNI %>%
  filter(MONTO_POR_DNI$DNI_ASEGURADO_LLAVE %in% Lista_DNI)
#Reducimos el nÃºmero de obs. en N_POLIZAS_DNI, eliminando todos los DNI que no estÃ¡n en Base_2018
Numero_Polizas <- N_POLIZAS_DNI %>%
  filter(N_POLIZAS_DNI$DNI_ASEGURADO_LLAVE %in% Lista_DNI)

#Los 3 Data Frames quedaron con menos de 30.000 observaciones, con lo que se asume que los DNIs que no estan en los nuevos Data Frames, 
#son personas que NO TIENEN registros historicos. Es decir, no han contratado un seguro antes, al menos no que estan en dicho registro.

#Con la funciÃ³n "merge" generamos un left join, donde usamos la Base_2018 como base y cruzamos los datos con las otras bases generadas, lo
#cual nos devuelve el valor asociado a DNI_ASEGURADO_LLAVE por ejemplo, creando una nueva columna e ingresando el valor en caso de existir.
#Si el valor no existe, ingresa un NA en su lugar.

Base_2018 <- merge(x = Base_2018, y = Numero_Polizas, by = "DNI_ASEGURADO_LLAVE", all.x = TRUE)
Base_2018 <- merge(x = Base_2018, y = Numero_Siniestros, by = "DNI_ASEGURADO_LLAVE", all.x = TRUE)
Base_2018 <- merge(x = Base_2018, y = Montos_Totales, by = "DNI_ASEGURADO_LLAVE", all.x = TRUE)
Base_2018 <- merge(x = Base_2018, y = Numero_Denuncias, by = "DNI_ASEGURADO_LLAVE", all.x = TRUE)

#Modificamos el nombre de la columna en Base_Ciudades para que tenga el mismo nombre que en Base_2018:
names(Base_Ciudades) <- c("SIN_NOMBRE_CIUDAD","Region")
#Dejamos Base_2018$SIN_NOMBRE_CIUDAD como character para que sea comparable con Base_Ciudades$SIN_NOMBRE_CIUDAD
Base_2018$SIN_NOMBRE_CIUDAD <- as.character(Base_2018$SIN_NOMBRE_CIUDAD)
Base_2018 <- merge(x = Base_2018, y = Base_Ciudades, by = "SIN_NOMBRE_CIUDAD", all.x = TRUE)

#Ahora TODOS los NA que quedaron en las nuevas columnas se deben igualar a 0, ya que como se mencionÃ³ mÃ¡s arriba, esto significa que estas
#personas no tienen registros histÃ³ricos.
anyNA(Base_2018$Region)
unique(Base_2018$Region)
apply(Base_2018, 2, pMiss)
apply(Base_2018, 2, pNULL)


Base_2018$conteoPolizas[is.na(Base_2018$conteoPolizas)] <- 0
Base_2018$conteoSiniestros[is.na(Base_2018$conteoSiniestros)] <- 0
Base_2018$sumaDeMontos[is.na(Base_2018$sumaDeMontos)] <- 0
Base_2018$conteoDenuncias[is.na(Base_2018$conteoDenuncias)] <- 0

###Dejamos guardada la Base_AUX_3 en caso de problemas mas adelante.
Base_AUX_3 <- Base_2018 ###/// USAR EN CASO DE TENER ERRORES MAS ADELANTE
###Base_2018 <- Base_AUX_3 ##//Activar en caso de emergencia

####################Eliminacion de observaciones pre procedo de DATA MINING####################

#Eliminamos las observaciones que cumplan con (Edad < 18 y DNI_ASEGURADO = DNI_DENUNCIANTE_LLAVE). Esto debido a que ningÃºn menor de edad en
#Chile estÃ¡ habilitado para hacer cobros o hacer efectivos los seguros. En esos casos debe ser su tutor legal quien haga efectivo el seguro.
#Como no podemos saber si DNI_DENUNCIANTE_LLAVE  en los casos en que DNI_ASEGURADO != DNI_DENUNCIANTE_LLAVE es alguien mayor de edad, se asumirÃ¡ que
#dicha persona si esta posibilitada a hacer efectivo el seguro.


Base_2018$Edad_Siniestro <- ifelse(Base_2018$Edad_Siniestro < 18 & Base_2018$DEN_ASEG_BIN == 1, NA,Base_2018$Edad_Siniestro)

#Ahora eliminamos los valores marcados anteriormente como NA

Base_2018 <- Base_2018[!is.na(Base_2018$Edad_Siniestro),]


#Procedemos a eliminar tambiÃ©n las personas >100 aÃ±os de la base. Este grupo etario es muy poco frecuente en Chile, ademas de existir en la base
#personas que incluso superan a la persona mas longeva de Chile en toda su historia, por ende, se procede a eliminar dichos registros:

Base_2018$Edad_Siniestro <- ifelse(Base_2018$Edad_Siniestro > 100, NA,Base_2018$Edad_Siniestro)

Base_2018 <- Base_2018[!is.na(Base_2018$Edad_Siniestro),]

#Procedemos tambien a eliminar a las personas no nacidas, o con edad < 0 anos, ya que es imposible que una persona que aun no nace participe de un siniestro.

Base_2018$Edad_Siniestro <- ifelse(Base_2018$Edad_Siniestro < 0, NA,Base_2018$Edad_Siniestro)

Base_2018 <- Base_2018[!is.na(Base_2018$Edad_Siniestro),]


apply(Base_2018, 2, pMiss)

###Dejamos guardada la Base_AUX_4 en caso de problemas mas adelante.
###Base_AUX_4 <- Base_2018 ###/// USAR EN CASO DE TENER ERRORES MAS ADELANTE


############################################
####      NormalizaciÃ³n de la base	    ####
############################################

#install.packages("ROSE")
library(ROSE)

table(Base_2018$CLASE) #Vemos la proporcion en la base entre NO y POSIBLE FRAUDE
#80054 NO y 7833 POSIBLE FRAUDE. Es decir, un 8,91% de POSIBLE FRAUDE, lo que nos da una entropia en torno al 43,6%

#Queremos reducir la muestra total a una cantidad trabajable por nuestros computadores, lo cual estÃ¡ en torno a las 30.000 observaciones.
#Ademas queremos disminuir un poco la brecha en la proporcion de las clases para aumentar el Information Gain a pesar de aumentar la entropÃ­a existente.
#Consideramos que es oportuno intentar llevar los POSIBLE FRAUDE a un 30% de la muestra total con la que trabajaremos, ya que si aumentamos
#mas existe el riesgo de sobre ajuste del modelo y un aumento desmedido de entropia.

#Primero vamos a hacer un undersampling para balancear la Base_2018:

Base_balance <- ovun.sample(CLASE ~ ., data = Base_2018, method = "both", p=0.3, N=30000, seed = 1)$data
#p: porcentaje que quiero que me quede de la clase que busco aumentar
#method: usamos "both" para reducir la base y aumentar la clase minoritaria.
#N: NÃºmero de observaciones que quieremos tenga la nueva base
table(Base_balance$CLASE)
#NO: 21044 POSIBLE FRAUDE: 8956, es decir 29,85% de POSIBLE FRAUDE, que es muy cercano a lo que buscÃ¡bamos.



#Cargamos la Base_Prediccion (Requerida)
Base_Prediccion <- read_excel("Tarea_2019S2_PrediccionRequerida.xlsx",col_names = TRUE)

#La Base_Prediccion tiene 142 NULLs en CUOTAS_PAG y 142 NULLs en MONTO_APROVADO. Ademas de 300 NULLs en ID_AVISO.

#Para unir las 2 bases, ambas deben tener las mismas variables, por lo que se procede a la modificacion de Base_Prediccion


##############################################################################################################
####################################### Modificaciones Base_Prediccion #######################################
##############################################################################################################

#Creamos Edad_Siniestro
Base_Prediccion$Edad_Siniestro <- year(ymd(Base_Prediccion$SIN_FECHA_OCURRENCIA))-year(Base_Prediccion$FECHA_NACIMIENTO)

#Creamos DICTAMEN
Base_Prediccion$DICTAMEN = ifelse(Base_Prediccion$HEV_DETAILS == 'EstadoEvaluaciones:Dictamen Aprobado', 1, 0)

#Creamos DEN_ASEG_BIN

Base_Prediccion$DEN_ASEG_BIN = ifelse(Base_Prediccion$DNI_ASEGURADO_LLAVE == Base_Prediccion$DNI_DENUNCIANTE_LLAVE, 1, 0)

#Transformamos todos los SIN_CUOTA_COBERTURA = 0 a 1, ya que el pago de los seguros debe ser al menos en una cuota.
Base_Prediccion$SIN_CUOTAS_COBERTURA[Base_Prediccion$SIN_CUOTAS_COBERTURA == 0 ] <- 1

#Creamos la variable CAUSA_Despido
Base_Prediccion <- Base_Prediccion %>%
  mutate(CAUSA_Despido = ifelse(Base_Prediccion$CAU_DESCRIPCION == 'Despido', 1, 0))
#Creamos la variable CAUSA_Robo
Base_Prediccion <- Base_Prediccion %>%
  mutate(CAUSA_Robo = ifelse(Base_Prediccion$CAU_DESCRIPCION == 'Robo', 1, 0))
#Creamos la variable CAUSA_Enfermedad
Base_Prediccion <- Base_Prediccion %>%
  mutate(CAUSA_Enfermedad = ifelse(Base_Prediccion$CAU_DESCRIPCION == 'Enfermedad', 1, ifelse(Base_Prediccion$CAU_DESCRIPCION == 'Enfermedades Graves', 1, 0)))
#Creamos la variable CAUSA_Incendio
Base_Prediccion <- Base_Prediccion %>%
  mutate(CAUSA_Incendio = ifelse(Base_Prediccion$CAU_DESCRIPCION == 'Incendio', 1, 0))
#Creamos la variable CAUSA_Otros
Base_Prediccion$CAUSA_Otros = ifelse(Base_Prediccion$CAU_DESCRIPCION == 'Despido', 0, ifelse(Base_Prediccion$CAU_DESCRIPCION == 'Robo', 0, ifelse(Base_Prediccion$CAU_DESCRIPCION == 'Enfermedad', 0, ifelse(Base_Prediccion$CAU_DESCRIPCION == 'ClonaciÃ³n', 0, ifelse(Base_Prediccion$CAU_DESCRIPCION == 'Incendio', 0,1)))))

#Transformar LOT_EXTERNO a binaria
Base_Prediccion$LE_BIN = ifelse(Base_Prediccion$LOT_EXTERNO == 'N', 0, 1)

#Transformar SIN_PAGO_ESPECIAL a binaria
Base_Prediccion$SPE_BIN = ifelse(Base_Prediccion$SIN_PAGO_ESPECIAL == 'N', 0, 1)


#CreaciÃ³n de conteoPolizas, conteoSiniestros, sumaDeMontos y Region para la Base_Prediccion

Base_Prediccion <- merge(x = Base_Prediccion, y = Numero_Polizas, by = "DNI_ASEGURADO_LLAVE", all.x = TRUE)
Base_Prediccion <- merge(x = Base_Prediccion, y = Numero_Siniestros, by = "DNI_ASEGURADO_LLAVE", all.x = TRUE)
Base_Prediccion <- merge(x = Base_Prediccion, y = Montos_Totales, by = "DNI_ASEGURADO_LLAVE", all.x = TRUE)


#Ahora TODOS los NA que quedaron en las nuevas columnas se deben igualar a 0, ya que como se menciona mas arriba, esto significa que estas
#personas no tienen registros historicos.
Base_Prediccion$conteoPolizas[is.na(Base_Prediccion$conteoPolizas)] <- 0
Base_Prediccion$conteoSiniestros[is.na(Base_Prediccion$conteoSiniestros)] <- 0
Base_Prediccion$sumaDeMontos[is.na(Base_Prediccion$sumaDeMontos)] <- 0



summary(Base_Prediccion)


###########################Guardamos la Base_Prediccion ante cualquier eventualidad############################//AUXILIAR
#########Base_AUX_Prediccion <- Base_Prediccion  ###/// USAR EN CASO DE TENER ERRORES MAS ADELANTE

#Seleccionamos las variables a utilizar de ambas bases, las cuales deben ser las mismas (variables).

Base_Mice_2 <- Base_balance %>%
  select(TIPO_EMPRESA_SEGURO, SIN_PAGO_ESPECIAL, SIN_CUOTAS_COBERTURA, SIN_NOMBRE_CIUDAD, CUOTAS_PAG, MONTO_APROBADO, CLASE, DICTAMEN, SPE_BIN, LE_BIN, CAUSA_Despido, CAUSA_Robo, CAUSA_Enfermedad, CAUSA_Incendio, CAUSA_Otros, DEN_ASEG_BIN, Edad_Siniestro, conteoPolizas, conteoSiniestros, sumaDeMontos)

Base_Mice_Prediccion <- Base_Prediccion %>%
  select(TIPO_EMPRESA_SEGURO, SIN_PAGO_ESPECIAL, SIN_CUOTAS_COBERTURA, SIN_NOMBRE_CIUDAD, CUOTAS_PAG, MONTO_APROBADO, CLASE, DICTAMEN, SPE_BIN, LE_BIN, CAUSA_Despido, CAUSA_Robo, CAUSA_Enfermedad, CAUSA_Incendio, CAUSA_Otros, DEN_ASEG_BIN, Edad_Siniestro, conteoPolizas, conteoSiniestros, sumaDeMontos)


summary(Base_Prediccion)
apply(Base_Mice_Prediccion, 2, pNULL)
apply(Base_Mice_Prediccion, 2, pMiss)

#Convertimos todos los NULLs a NAs en la Base_Mice_Prediccion
Base_Mice_Prediccion$SIN_NOMBRE_CIUDAD[Base_Mice_Prediccion$SIN_NOMBRE_CIUDAD == "NULL"] <- NA
Base_Mice_Prediccion$CUOTAS_PAG[Base_Mice_Prediccion$CUOTAS_PAG == "NULL"] <- NA
Base_Mice_Prediccion$MONTO_APROBADO[Base_Mice_Prediccion$MONTO_APROBADO == "NULL"] <- NA

##########UNIMOS LA Base_Mice_2 y Base_Mice_Prediccion#################

Base_Full <- rbind(Base_Mice_2, Base_Mice_Prediccion)

#Separamos en un vector la columna CLASE para no modificarla

Clases_Full <- Base_Full$CLASE

#Apartamos la variable CLASES

Base_Full <- Base_Full %>%
  select(-CLASE)

#Tiramos un MICE para rellenar los NA de la Base_Prediccion

summary(Base_Full)





#Crear DataFrame auxiliar y correr mice
Full_Mice <- Base_Full %>%
  select(CAUSA_Despido, CAUSA_Robo, CAUSA_Enfermedad, CAUSA_Incendio, CAUSA_Otros, SPE_BIN, LE_BIN, SIN_CUOTAS_COBERTURA, SIN_NOMBRE_CIUDAD, CUOTAS_PAG, MONTO_APROBADO)
summary(Full_Mice)

#Convertimos en Factor y Numeric los valores que asi lo requieren
Full_Mice$SIN_NOMBRE_CIUDAD <- as.factor(Full_Mice$SIN_NOMBRE_CIUDAD)
Full_Mice$CUOTAS_PAG <- as.numeric(Full_Mice$CUOTAS_PAG)
Full_Mice$MONTO_APROBADO <- as.numeric(Full_Mice$MONTO_APROBADO)



mod_miceFull <-mice(data = Full_Mice, m = 10,meth='cart')
Full_Mice_V1 <- mice::complete(mod_miceFull)

anyNA(Full_Mice_V1)
sum(is.na(Full_Mice_V1))
summary(Full_Mice_V1)

#Los datos ya corregidos por Mice se integran a la base original, sobreescribiendo los anteriores
Base_Full$SIN_NOMBRE_CIUDAD <- Full_Mice_V1$SIN_NOMBRE_CIUDAD
Base_Full$CUOTAS_PAG <- Full_Mice_V1$CUOTAS_PAG
Base_Full$MONTO_APROBADO <- Full_Mice_V1$MONTO_APROBADO

anyNA(Base_Full)
summary(Base_Full)

###########################Guardamos la Base_Full ante cualquier eventualidad############################//AUXILIAR
#########Base_AUX_PostMice <- Base_Full ##///Base completa sin NA ni la variable CLASE.
##Base_Full <- Base_AUX_PostMice ## // ACTIVAR EN CASO DE EMERGENCIA
CLASE <- Clases_Full
#Antes de aplicar los cambios en la Base nuevamente, tenemos que volver a agregar la lista de CLASE, ya que  la funcion "merge" alterara el orden de las observaciones.
Posicion <- c(1:30300) #La funcion mergen agrega algunos valores (7 en total), por lo que con la columna Posicion sabremos cuales duplica y/o agrega.
Base_Full <- cbind(Base_Full, CLASE, Posicion)


#Ahora que tenemos los valores completos en Base_Full podremos cambiar SIN_NOMBRE_CIUDAD a numeric, tal como lo hicimos en Base_2018
#Dejamos Base_Prediccion$SIN_NOMBRE_CIUDAD como character para que sea comparable con Base_Ciudades$SIN_NOMBRE_CIUDAD
Base_Full$SIN_NOMBRE_CIUDAD <- as.character(Base_Full$SIN_NOMBRE_CIUDAD)
Base_Full <- merge(x = Base_Full, y = Base_Ciudades, by = "SIN_NOMBRE_CIUDAD", all.x = TRUE)

#Vemos que valor duplica:
n_occur <- data.frame(table(Base_Full$Posicion))
#Eliminamos los 7 valores que se duplicaron y la base queda tal como deberÃ­a estar:
Base_Full<- Base_Full[!duplicated(Base_Full$Posicion), ]

#Quitamos SIN_NOMBRE_CIUDAD y solo nos quedamos con Region y ademÃ¡s quitamos el valor Posicion
Base_Full <- Base_Full %>%
  select(-SIN_NOMBRE_CIUDAD, -Posicion)

#Transformamos la variable CLASE a binario, creando la nueva variable Clase_bin
Base_Full$Clase_bin = ifelse(Base_Full$CLASE == 'POSIBLE FRAUDE', 1, 0)

#Volvemos a separar la variable CLASE y Clase_bin, esta vez para normalizar

Clase_Separacion <- data.frame(Base_Full$CLASE, Base_Full$Clase_bin)

Base_Full_Preproces <- Base_Full %>%
  select(-CLASE, -Clase_bin, -SIN_PAGO_ESPECIAL)



#Se quita SIN_PAGO_ESPECIAL ya que su efecto esta capturado en SPE_BIN

##############################################################################################################
############################################## NORMALIZACIÃN #################################################
##############################################################################################################
summary(Base_Full_Preproces)
library(lattice)
#Creamos una funcion para escalar variables numericas y la guardamos con el nombre de "scalling"
scalling <- function(x){(x-min(x))/(max(x)-min(x))}

Base_Full_Preproces$SIN_CUOTAS_COBERTURA <- scalling(Base_Full_Preproces$SIN_CUOTAS_COBERTURA)
Base_Full_Preproces$CUOTAS_PAG <- scalling(Base_Full_Preproces$CUOTAS_PAG)
Base_Full_Preproces$MONTO_APROBADO <- scalling(Base_Full_Preproces$MONTO_APROBADO)
Base_Full_Preproces$DICTAMEN <- scalling(Base_Full_Preproces$DICTAMEN)
Base_Full_Preproces$SPE_BIN <- scalling(Base_Full_Preproces$SPE_BIN)
Base_Full_Preproces$LE_BIN <- scalling(Base_Full_Preproces$LE_BIN)
Base_Full_Preproces$CAUSA_Despido <- scalling(Base_Full_Preproces$CAUSA_Despido)
Base_Full_Preproces$CAUSA_Robo <- scalling(Base_Full_Preproces$CAUSA_Robo)
Base_Full_Preproces$CAUSA_Enfermedad <- scalling(Base_Full_Preproces$CAUSA_Enfermedad)
Base_Full_Preproces$CAUSA_Incendio <- scalling(Base_Full_Preproces$CAUSA_Incendio)
Base_Full_Preproces$CAUSA_Otros <- scalling(Base_Full_Preproces$CAUSA_Otros)
Base_Full_Preproces$DEN_ASEG_BIN <- scalling(Base_Full_Preproces$DEN_ASEG_BIN)
Base_Full_Preproces$Edad_Siniestro <- scalling(Base_Full_Preproces$Edad_Siniestro)
Base_Full_Preproces$conteoPolizas <- scalling(Base_Full_Preproces$conteoPolizas)
Base_Full_Preproces$conteoSiniestros <- scalling(Base_Full_Preproces$conteoSiniestros)
Base_Full_Preproces$sumaDeMontos <- scalling(Base_Full_Preproces$sumaDeMontos)
Base_Full_Preproces$Region <- scalling(Base_Full_Preproces$Region)


######Reincorporamos las variables CLASE y Clase_bin

names(Clase_Separacion) <- c("CLASE", "Clase_bin")
Base_Full_ml <- cbind(Base_Full_Preproces, Clase_Separacion)

Base_Full_ml <- Base_Full_ml %>%
  select(-CLASE)

#Ahora separamos nuevamente las bases como train y test para el DATA MINING:



#ExtracciÃ³n de la base train
Base_Full_ml_train <- Base_Full_ml%>%
  filter(is.na(Clase_bin)==FALSE)

#ExtraciÃ³n de la base test // Esta es la base final que nos piden predecir
Base_Full_ml_test <- Base_Full_ml%>%
  filter(is.na(Clase_bin)==TRUE)

summary(Base_Full_ml_train)

correlacion1<-Base_Full_ml_train %>% 
  select(SIN_CUOTAS_COBERTURA, CUOTAS_PAG, MONTO_APROBADO,DICTAMEN, CAUSA_Despido, CAUSA_Robo, CAUSA_Enfermedad, CAUSA_Incendio, CAUSA_Otros, SPE_BIN, LE_BIN, SIN_CUOTAS_COBERTURA, DEN_ASEG_BIN, Edad_Siniestro, conteoPolizas, conteoSiniestros, sumaDeMontos, Region, Clase_bin)%>% 
  correlate() %>% 
  focus(Clase_bin)


#Base_Full_ml Tiene todas las variables a utilizar para el modelo, incluyendo la variable Clase_bin
#
#Base_Full_ml_train corresponde a los datos de la Base_2018
#
#Base_Full_ml_test corresponde a los datos de la Base_Prediccion
#

##En esta parte procedemos a realizar un anÃ¡lisis por correralacion entre las variables numÃ©ricas, con foco en Clase_bin


###FILTRO POR CORRELACION
#Filtramos las variables que tiengan una correlacion menor a 0.05 (en valor absoluto).
correlacion2<-correlacion1 %>% 
  filter(Clase_bin >=0.05 | Clase_bin <=-0.05 )
#AcÃ¡ estamos diciendo que filtre: >=0.05 O <0.05 CUALQUIREA QUE CUMPLA UNA DE ESAS CONDICIONES SE QUEDA
correlacion2 <- correlacion2[,1]
View(correlacion2)

#Ahora en la tabla correlacion2 tenemos las variables en una columna
#Procedemos a crear el vector
Variables_correlacion <- c()

for ( i in 1:nrow(correlacion2)){
  Variables_correlacion <-c(correlacion2[[i]])}

#Crearemos una Base con las variables filtradas por correlacion
Base_preml <- subset(Base_Full_ml_train, select=Variables_correlacion)
#Agregamos la varaible no numÃ©rica a utilizar
Base_preml$TIPO_EMPRESA_SEGURO <- Base_Full_ml_train$TIPO_EMPRESA_SEGURO
View(Base_preml)
Variables_correlacion_1 <- c(Variables_correlacion, "TIPO_EMPRESA_SEGURO", "Clase_bin")

Base_preml_train <- Base_Full_ml_train

## Base_Full_ml_train vendria siendo la base "Scapegoat" que pusiste en tu codigo

#
#Como se detalla en el informe, si se corrieron 2 modelos bajo el criterio de la correlacion, pero al mostrar peores resultados que los modelos
#con 19 variables, en el codigo solo se conservÃ³ la parte que agrega las 19 variables a Base_preml_train 


#
#
#                                        ETAPA DE DATA-MINING
#
#


library(caret)
library(ggplot2)
library(h2o)
library(recipes)
library(C50)
library(e1071)
library(rpart.plot)
library(rpart)
library(ROSE)




#SeparaciÃ³n en training y testing desde la Base_Full_ml_train

Base_preml_train$Clase_bin <- as.factor(Base_preml_train$Clase_bin)
Base_preml_train$TIPO_EMPRESA_SEGURO <- as.factor(Base_preml_train$TIPO_EMPRESA_SEGURO)

inTraining <- createDataPartition(Base_preml_train$Clase_bin, p=.70, list= FALSE)

training <- Base_preml_train[inTraining,]
testing <- Base_preml_train[-inTraining,]

#
#      DECISSION TREE
#

# Entrenamiento de la base training utilizando el metodo decission tree
model_DT <- train(
  Clase_bin ~ ., training,
  method = "C5.0",
  trControl = trainControl(
    method = "cv", number = 10,
    verboseIter = TRUE
  )
)

#Aplicar el modelo en la base testing
DTprediction <-predict(model_DT, testing)
cmDT <-confusionMatrix(DTprediction,testing$Clase_bin,  positive = "1")
print(cmDT)

summary(cmDT)
print(model_DT)
plot(model_DT)
install.packages("rpart")
library(rpart.plot)
tree <- rpart(Clase_bin ~ ., data=training, cp=.02)
rpart.plot(tree, box.palette="RdBu", shadow.col="gray", nn=TRUE)


#
#      NEURAL NETWORK
#

# Entrenamiento de la base training utilizando el metodo neural network
model_NN <- train(
  Clase_bin ~ ., training,
  method = "nnet",
  trControl = trainControl(
    method = "cv", number = 10,
    verboseIter = TRUE
  )
)

#Aplicar el modelo en la base testing
NNprediction <-predict(model_NN, testing)
cmNN <-confusionMatrix(NNprediction,testing$Clase_bin, positive = "1")
print(cmNN)

#
#       MODELO SVM
#


# Entrenamiento de la base training utilizando el metodo de support vector machine
#install.packages("e1071")
#library(e1071)

model_SVM <- train(
  Clase_bin ~ ., training,
  method = "svmPoly",
  trControl = trainControl(
    method = "cv", number = 10,
    verboseIter = TRUE
  )
)

#Aplicar el modelo en la base testing
SVMprediction <-predict(model_SVM, testing)
cmSVM <-confusionMatrix(SVMprediction,testing$Clase_bin, positive = "1")
print(cmSVM)

#Resumen modelo SVM
summary(model_SVM)
#Aca pueden ver cada una de las configuraciones en cada Kfold y sus respectivas metricas 
print(model_SVM)
#PLOT CON LOS ACCURACY DE LAS DIFERENTES CONFIGURACIONES
plot(model_SVM)


#
#
#



#Realizar la predicciÃ³n con el mejor modelo (DT 19 variables training 70% y testing 30%)
Best_model <- model_DT
#Corremos el predict() con el Best_model y la Base_Full_ml_test
prediccion_final <- predict(Best_model, Base_Full_ml_test)


##
##NOTA: Recordar que el orden de las filas en la Base_Full_ml_test NO ES EL MISMO que la Base_Prediccion original,
##ya que al utilizar la funcion merge() para agregar las nuevas variables desde la Base_Historica, esta si bien 
##NO ALTERA la informacion contenida en las filas, si modifica su posicion original.
##Es decir, si se usa la columna de prediccion_final para reemplazar la variable CLASE en el Excel Tarea_2019S2_PrediccionRequerida, los valores no coincidirÃ¡n.
## 
View(prediccion_final)

#Exportamos la prediccion realizada
write.csv(prediccion_final,file="prediccionCompleta.csv")
#CSV ESTA EN LA CARPETA DONDE ESTA EL ARCHIVO DE R
